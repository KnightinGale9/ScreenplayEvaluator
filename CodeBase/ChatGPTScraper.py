import json

import nltk
import pandas as pd
import spacy
import seaborn as sns
import colorcet as cc
import regex as re
from CodeBase.Scraper import Scraper

class ChatGPTScraper(Scraper):
    """
    Child Class of Scraper that scrapes the screenplay generated by ChatGPT and creates the dictionary for
    quick conversion to a dataframe
    Attributes:
        screenplay : Dictionary that holds all the data of the screenplay
            sentence_index : the index of the sentence in relation to the full screenplay
            type : The denotion of if the text is heading or dialogue as denoted by HEADING or CHARCTER
            terior : The current scene's location type of INT./EXT.
            heading : The master location of the scene
            subheading : The secondary heading of the scene
            ToD : The scene denoted time of day.
        location_list : A list holding the index of all scene changes
        sentences : A list holding all the raw text of the screenplay.
    """
    def __init__(self,dirpath,file_path):
        self.dir_path=dirpath
        try:
            with file_path.open("r", encoding="utf-8") as file:
                self.data = file.read()
            self.filename=file_path.name

            # match = re.search(r"\/(.*)$", file_path.name)
            # # if match:
            # #     self.filename = match.group(1)
            print(self.filename)
        except FileNotFoundError:
            print(file_path+ " was not found.")

    def screenplay_scrape(self):
        """
        Scraping text from a screenplay generated by ChatGPT based on the following system prompt.
            "You are a screenwriter's assistant. \
            Format the screenplay so it would be in the left justified of the page. \
            Your task is to generate screenplay scenes that include the following: \
            1. Scene heading: INT./EXT. LOCATION - TIME OF DAY.\
            2. Action: Use descriptive paragraphs to set up the scene, location, and environment. Use short and visual description to set up the scene and enviorment. \
            3. Character: The name of the person speaking, in all caps. \
            4. Dialogue: What the character says. \
            5. Parentheticals: If necessary, to describe how the dialogue is delivered."

        The scraping process extracts and structures these elements for further analysis or processing.

        :return:
        """

        self.screenplay = {'sentence_index': [], 'type': [], 'terior': [], 'heading': [], 'subheading': [], 'ToD': [],
                      'text': []}
        self.location_list = []
        self.sentences=[]
        self.character_real_set = set()
        sent_idx = 0
        location = ""

        story_combine = ""
        pattern1 = r".*(INT\.|EXT\.|I\/E\.|INT\.\/EXT\.)\s+(.*)\s+[-—–]\s+(.*)\s*.*"
        pattern2 = r".*(INT\.|EXT\.|I\/E\.|INT\.\/EXT\.)\s+(.*)\s+[-—–]\s+(.*)\s+[-–]\s+(.*)\s*.*"
        screen = self.data.split("\n\n")

        for text in screen:
            i = len(self.screenplay['type'])

            # print(i,text)
            if "EXT." in text or "INT." in text:
                # if text != location:
                location = text.replace("\n","").strip()
                # print(i, text)
                self.location_list.append(i)
                continue
            trans=r"^\b(?:FADE IN|FADE OUT|DISSOLVE TO|CUT TO|SMASH CUT|IRIS IN AND IRIS OUT|JUMP CUT|FLASHBACK|TIME CUT|THE END.)\b(.*)"
            if re.match(trans,text):
                mat = re.match(trans, text)
                print(text)
                if mat.group(1) is not None:
                    continue

            character = text.split("\n")
            if character[0].isupper():
                character_name = character[0].split("(")
                self.screenplay["type"].append(character_name[0].strip())
                temp = ""
                for tt in character[1:]:
                    temp += tt
                pharentetical = r'(\(.*?\))?\s*(.*)'
                mat = re.match(pharentetical, temp)
                self.screenplay["text"].append(mat.group(2))
                sent = nltk.sent_tokenize(mat.group(2))
                sent_idx += len(sent)
                self.sentences.extend(sent)
                self.screenplay["sentence_index"].append(sent_idx)

            else:
                self.character_real_set.update(re.findall(r'\b(?:[A-Z\']{2,}(?:\s+[A-Z\']{2,})*)\b', text))
                self.character_real_set.update(re.findall(r'\b[A-Z]{2,}\b', text))
                self.screenplay["type"].append("HEADING")
                self.screenplay["text"].append(text)
                sent = nltk.sent_tokenize(text)
                sent_idx += len(sent)
                self.sentences.extend(sent)
                self.screenplay["sentence_index"].append(sent_idx)

            if re.match(pattern2, location):
                mat = re.match(pattern2, location)
                self.screenplay['terior'].append(mat.group(1))  # INT.
                self.screenplay['heading'].append(mat.group(2))  # ANCIENT CITY
                self.screenplay['subheading'].append(mat.group(3))  # UNDERGROUND PASSAGE
                self.screenplay['ToD'].append(mat.group(4))  # NIGHT
                # location_list.append(i)

            elif re.match(pattern1, location):
                mat = re.match(pattern1, location)
                self.screenplay['terior'].append(mat.group(1))  # INT.
                self.screenplay['heading'].append(mat.group(2))  # ANCIENT CITY
                self.screenplay['subheading'].append(None)  # UNDERGROUND PASSAGE
                self.screenplay['ToD'].append(mat.group(3))  # NIGHT
                # location_list.append(i)
            else:
                print(location,text)
                print("error")
            # screenplay["location"].append(location)
            # sent = nltk.sent_tokenize(text)
            # sent_idx += len(sent)
            # self.sentences.extend(sent)
            # self.screenplay["sentence_index"].append(sent_idx)
        temp = set(self.location_list)
        self.location_list = list(temp)
        self.location_list.sort()
        for ss in self.screenplay:
            print(len(self.screenplay[ss]))

    def count_sentences(self,text):
        """
        A helper function to help count the number of sentences in a screenplay.

        :param text: text
        :return: sentence count for text
        """
        # Use regular expression to find sentences
        sentences = re.split(r'[.!?]+', text)

        # Filter out empty strings and count
        return len([s for s in sentences if s.strip()])

    def get_json_data(self):
        """
        A function to retrieve the data created by scraper for Screenplay_Raw_data.json
        :return: self.screenplay,self.characterdict,self.location_list
        """
        return self.screenplay,self.characterdict,self.location_list

